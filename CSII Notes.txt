assert args.length == 1 : "Wrong number of arguments"; //use java -ea <class> to enable assertions
//used for finding errors

//-----------------------debugger------------------------
//allows you to run a little bit of code at a time
//javac -g <class>.java  use this to compile it for debugging
//jdb <class>  			 use this to start debugging
//stop at <class>:10     will stop at line 10 
//print stringName       prints the string value
//step 					 moves to the next line
//cont					 will continue until it reaches a breakpoint
//set variableName = ... sets a variable to a certain value
//look up other jdb commands like: dump, where, stop in, etc.

//------------------------Test----------------------------
//Unit test - test the method of an object to see if it outputs the wanted results
//Test suite - runs many test at once
//Regression testing - re-test old code when changes are made
//include tests in main() or in a test() method OR a Test class
//------------example of creating a test-------
public int distance(int x, int x2)
{
	return x2-x1;
}
public static void main(string[] args)
{
	if(distance(10,5) == 5)
		System.out.println("distance method works correctly!");
	else
		System.out.println("distance method not working correctly!");
}
//-------------------------Recursion-------------------------
public static int sum(int sumTo)
{
	if(sumTo == 1) //base case
		return 1;
	else{
		return (sumTo + sum(sumTo - 1));
		
	}
}
//recursive statements have:
//Branching if statements
//Base cases: if the problem is small enough return the obvious answer
//Every execution must end in a base case
//recursive cases:
//	call the function again, on smaller input
//	computer with the answer in some way and return it
//-===========================Inheritance-=================================
//inheritance is just extending another class 
//it gets its variables and methods so long as they are declared public or protected 

//------------------Polymorphism-------------------------
@lookup javadoc comments
-promotes code reuse
-promotes code sharing

-object, person, student, undergrad
^ inheritance





assignment 4----------

an undergrad is a student,person,and an object
a student is a person, object. etc.
^polymorphism*

-casting up is okay, casting down is not!
Undergraduate u = new Undergraduate();
Student s = u;  //okay because an undergraduate IS also a student
Undergraduate u2 = s; //will NOT work..must cast (undergraduate)
Undergraduate u2 = (Undergraduate)s; // okay!

Student s = new Student();
Undergraduate u = s; //NOT okay because a student is NOT an undergraduate

undergrad --> student --> person --> object
student = (student)undergrad;
student = person;
undergrad = student;
object = (object)undergrad;

----------------------------------------------------
common to use super.method(); when overwriting in the subclass
super.super.method(); //NOT ALLOWED*

java's object class has the method toString();
so you can override toString(); (called everytime you print an object)
public String toString(){} //to override Object.toString();

-----------------Abstract classes-----------------
public abstract class Dog{
	public abstract int scoreAccordingToStandard();
}
//abstract means you cannot create a dog object
-abstact classes leave one or more methods undefined
-cannot instantiate abstract classes directly
-subclasses must implement each abstract method
-a class can only extend 1 abstract class, 
	-while it can implement multiple interfaces


public class Labrador extends Dog
{
	public int scoreAccordingToStandard(){}
}
//----------------------INTERFACES----------------------------
public Comparable arrayMaximum(Comparable[] arr)
{
	
}

Random(long seed) //seeds the random number to have a particular sequence

public class MyPanel extends JPanel
{
	public void paintComponent(Graphics g)  //overrides method in Component class (parent of JPanel)
	{
		super.paintComponent(g); //very  important
		
	}
}

use the whole screen as parameters at first then divide the entire screen into thirds 1 up 2 below
----------------------------------------Widgets--------------------------------------------

------Menus-----
-Menu Bar
	
-Menus
-Menu items
-ActionListeners
---------------------------
Model -> view -> user -> controller ->repeat
view asks for models status then draws it
controller modifies the model
user uses the controller

-----------------
main class
	only instantiates jframe
JFrame subclass
	-jpanel
	-jmenuitems
	-pass this to menus and panels
	-has model object
	-listeners ask from for model object

--------------------------------TIMERS AND ANIMATION------------------------------------
Timer time = new Timer(100,actionHandler); 

--------------Streams--------------------------Streams--------------------------
--useful io streams--
FileReader, FileWriter: text files
BufferedReader, BufferedWriter: Anything text oriented that isn't a file
PrintWriter: write strings and data as strings
PrintStream: hybrid, writes Strings and bytes, catches errors internally
DataInputStream, DataOutputStream: Binary primitives
BufferedINputStream, BufferedOutputStream: raw byte arrays
ObjectInputStream: serialized objects
Scanner

System.in		//this is an InputStream

//this reads the inputStream, converts bytes to ints representing chars
InputStreamReader isr = new InputStreamReader(System.in);
//BufferedReader takes the InputStreamReader ints converts to a String
BufferedReader br = new BufferedReader(isr); 

------------------------Test Review------------------------
allowed 1 page of notes front and back

JVM- Java Virtual Machine -- fake machine translating byte code to machine code-
primitive types-variables of value int,long,etc
instance variable- data of a particular instance of a class
public private-encapsulation so inner working of classes isnt accessible
pass by reference, value- reference = objects are passed by reference, primitive = passed by value
things passed by reference actually manipulate the data
pass by value is just a copy that doesnt effect any outside data
javadoc - written with your code, effort to make documentation easier
assertion - run program with assertions enables to test program
debugger - lets you examine your code and execute 1 at a time
Unit test - test a method to see if the output is correct
Recursion - objects that contain objects of the same type or methods that call themselves
recursion pattern - have a base case then have a case that calls the method again until the base case is satisfied

static methods and variables - does not belong to any instance 
overloading - create methods with the same name and return type but have diff num of arguments
overriding - replaces a method from a parent class 
final variables - constant variables that cannot be changed once initialized
casting - change the variables type or reference type for objects
abstract class - cannot be instantiated, contains abstract methods. methods that arent defined meant for subclasses to defined
Interface - like an abstract class but all methods are abstract, classes must implement all methods, used mostly for polymorphism
Timer - used to call an actionEvent every given amount of ms
layout - organizes your panel or jcomponent
event - something that happens that event loop catches 
listeners - mouse listener, action listeners etc.
inner class - listeners are often inner classes, have access to the data of the class its in
exception - for handling errors that are caused by the outside world, not neccessarily the programmers errors
Stream - communicating between two entities, ordered sequence of bytes,
Readers & Writers - implement text processing, read bytes convert to chars, write to files, etc
File object - an object that can represent a file in the pc
Garbage collector - scans and finds useless memory then deletes it 

encapsulation - protecting data in classes from outside use so others don't have to think about how it works

inheritance - OOP allows classes to inherit from other classes 
	used for code reusability
	subclasses have access to parent classes public/protected data and methods

event handling - eventloop runs over and over waiting for something to set it off like user input
	-
		
MVC - Model - Data and program logic
	- View 	- Widgets and Panels (Components and Panels)
	- Controller - contains handlers. To tell the view and model how to behave
	
-------------------------How the Internet Works---------------------------

transport protocol: In charge of transporting bytes in proper order
	TCP: reliable, not as fast, makes sure to recieve all data, has error correction if bytes are missing it asks for them again
	UDP:	recieves packets of data, if some are missing it just drops it and continues, good for video streaming
application protocol: structure of the data
	HTTP: For webservers


socket:	
	setSoTimeout(int timeout); 	//set how long to wait on response before giving up

InetAddress:
	getLocalHost();
	getByName();				//InetAddress.getByName("cs.okstate.edu");
	getByAddress();
	isReachable(int timeout);

ServerSockets:
	accept();			//waits for a connection to be made, code stops at this until someone connects
	
Thread--------------------------------------------------------------------
Thread.setPriority(int newPriority);	//number from 1 to 10, higher numbers run more often
Thread.yield();		//tells java that this Thread can wait for others now

--------------------------------------Generics--------------------------------------------------------------
Integer a = 3000;
Integer b = 3000;
if(a == b){				//returns false because you are comparing two objects, which compares memory addresses

}

ArrayList list = new ArrayList();
list.add(5);									//automatically converts to an Integer object and adds it to the list
list.get(0);									//this returns an Object object does NOT automatically convert to an Integer object
note: you could do ((Integer)list.get(0)) but no thanks

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.get(0);			//now it knows that its returning an Integer object 


order of growth-----------------
O(1)			constant
O(log n)		sublinear
O(n)			linear
O(n log n)	
O(n^2)		quadratic			//double input equals quadrupal amount of work, nested loops 
O(n^k)		polynomial
O(2^n)		Exponential
O(n!)			Factorial

O(1)		size of the input has no influence

O(log n)	Algorithm doesnt have to look at every data element
			Recursion makes problem smaller through division
			divide the size of the problem every loop

O(n)		Going through a loop once and doing an operation at each increment 
			no nested loops
			recursion makes problem smaller through subtraction
			subtract from size of problem every loop
			
O(n log n)



O(n^k)



O(n^2):
	double for loops	
	
O(2^n):
	


			
			
-------------------------------------------------Sorting-----------------------------------------Sorting-----------------------------------------Socket
1. sorting is an O(nlog(n)) order of growth

selection sort:
	
Bubble sort:
	run through the array and swap if they are out of order
	good for list that are already almost sorted
	O(n^2)
	
insertion sort:
	O(n^2)
	stable
	O(n) on nearly sorted list
	better than bubble sort

Merge sort:
	recursive sort
	take a list divide it by 2
	look at first element of both list
		put the smaller element in a new array
		increment index of the array with the smaller element
		repeat
	O(n) sort or nlog(n) because youre dividing 

Quick sort:
	choose a random index and put it at the start
	find the first number less than the pivot point
	move that number to the right of the pivot point
	swap the pivot with the element two to the right?

Heapsort:

linear time sort:


-------------------------------------------Data structures---------------------------------Data structures---------------------------------Data

Linked list:


bucket sort:
	like counting sort but using a single digit
	
radix sort:  O(n) * k where k is the number of digits
	use bucket sort on last digit
	create new list sorted by last digits
	bucket sort on second to last digit
	create new list sorted by second to last digits
	repeat to first digit
	
radix sort only works for integers but you can use hashcodes to represent anything
everything in code is ultimately just binary 0's and 1's which can be represented as a number

hashcode() returns a number between 2billionish to -2billionish

idea: a binary tree but with 4 children by comparing the key into 4ths
1/4 go downleft 1/2 go up left 3/4 up right etc.




assignment 6--------------------------------------------------------------------------------------------------------------
2's compiment
00000001	= 1
11111110	= -2

00000000  = 0
11111111  = -1

bit shifting----------
<< left shifting

			1 << 2 = 4
00000001 << 2 = 00000100

>> rightshifting
	-fills in 1's
	
>>> rightShifting
	fills in with 0's
	
bitwise &:
	30 & 105 == 8
	if both are 1 set bit to 1 
	00011110 & 01101001 == 00010000

bitwise |:
	if either are 1 then set to 1
	
setting i'th bit to 1:
	- a = a | (1 << i);
	
huffman codes--------------------------------------------------------






















