assert args.length == 1 : "Wrong number of arguments"; //use java -ea <class> to enable assertions
//used for finding errors

//-----------------------debugger------------------------
//allows you to run a little bit of code at a time
//javac -g <class>.java  use this to compile it for debugging
//jdb <class>  			 use this to start debugging
//stop at <class>:10     will stop at line 10 
//print stringName       prints the string value
//step 					 moves to the next line
//cont					 will continue until it reaches a breakpoint
//set variableName = ... sets a variable to a certain value
//look up other jdb commands like: dump, where, stop in, etc.

//------------------------Test----------------------------
//Unit test - test the method of an object to see if it outputs the wanted results
//Test suite - runs many test at once
//Regression testing - re-test old code when changes are made
//include tests in main() or in a test() method OR a Test class
//------------example of creating a test-------
public int distance(int x, int x2)
{
	return x2-x1;
}
public static void main(string[] args)
{
	if(distance(10,5) == 5)
		System.out.println("distance method works correctly!");
	else
		System.out.println("distance method not working correctly!");
}
//-------------------------Recursion-------------------------
public static int sum(int sumTo)
{
	if(sumTo == 1) //base case
		return 1;
	else{
		return (sumTo + sum(sumTo - 1));
		
	}
}
//recursive statements have:
//Branching if statements
//Base cases: if the problem is small enough return the obvious answer
//Every execution must end in a base case
//recursive cases:
//	call the function again, on smaller input
//	computer with the answer in some way and return it
//-===========================Inheritance-=================================
//inheritance is just extending another class 
//it gets its variables and methods so long as they are declared public or protected 

//------------------Polymorphism-------------------------
@lookup javadoc comments
-promotes code reuse
-promotes code sharing

-object, person, student, undergrad
^ inheritance





assignment 4----------

an undergrad is a student,person,and an object
a student is a person, object. etc.
^polymorphism*

-casting up is okay, casting down is not!
Undergraduate u = new Undergraduate();
Student s = u;  //okay because an undergraduate IS also a student
Undergraduate u2 = s; //will NOT work..must cast (undergraduate)
Undergraduate u2 = (Undergraduate)s; // okay!

Student s = new Student();
Undergraduate u = s; //NOT okay because a student is NOT an undergraduate

undergrad --> student --> person --> object
student = (student)undergrad;
student = person;
undergrad = student;
object = (object)undergrad;

----------------------------------------------------
common to use super.method(); when overwriting in the subclass
super.super.method(); //NOT ALLOWED*

java's object class has the method toString();
so you can override toString(); (called everytime you print an object)
public String toString(){} //to override Object.toString();

-----------------Abstract classes-----------------
public abstract class Dog{
	public abstract int scoreAccordingToStandard();
}
//abstract means you cannot create a dog object
-abstact classes leave one or more methods undefined
-cannot instantiate abstract classes directly
-subclasses must implement each abstract method
-a class can only extend 1 abstract class, 
	-while it can implement multiple interfaces


public class Labrador extends Dog
{
	public int scoreAccordingToStandard(){}
}
//----------------------INTERFACES----------------------------
public Comparable arrayMaximum(Comparable[] arr)
{
	
}

Random(long seed) //seeds the random number to have a particular sequence

public class MyPanel extends JPanel
{
	public void paintComponent(Graphics g)  //overrides method in Component class (parent of JPanel)
	{
		super.paintComponent(g); //very  important
		
	}
}

use the whole screen as parameters at first then divide the entire screen into thirds 1 up 2 below
----------------------------------------Widgets--------------------------------------------

------Menus-----
-Menu Bar
	
-Menus
-Menu items
-ActionListeners
---------------------------
Model -> view -> user -> controller ->repeat
view asks for models status then draws it
controller modifies the model
user uses the controller

-----------------
main class
	only instantiates jframe
JFrame subclass
	-jpanel
	-jmenuitems
	-pass this to menus and panels
	-has model object
	-listeners ask from for model object

--------------------------------TIMERS AND ANIMATION------------------------------------
Timer time = new Timer(100,actionHandler); 

--------------Streams--------------------------Streams--------------------------
--useful io streams--
FileReader, FileWriter: text files
BufferedReader, BufferedWriter: Anything text oriented that isn't a file
PrintWriter: write strings and data as strings
PrintStream: hybrid, writes Strings and bytes, catches errors internally
DataInputStream, DataOutputStream: Binary primitives
BufferedINputStream, BufferedOutputStream: raw byte arrays
ObjectInputStream: serialized objects
Scanner

System.in		//this is an InputStream

//this reads the inputStream, converts bytes to ints representing chars
InputStreamReader isr = new InputStreamReader(System.in);
//BufferedReader takes the InputStreamReader ints converts to a String
BufferedReader br = new BufferedReader(isr); 

------------------------Test Review------------------------
allowed 1 page of notes front and back

JVM- Java Virtual Machine -- fake machine translating byte code to machine code-
primitive types-variables of value int,long,etc
instance variable- data of a particular instance of a class
public private-encapsulation so inner working of classes isnt accessible
pass by reference, value- reference = objects are passed by reference, primitive = passed by value
things passed by reference actually manipulate the data
pass by value is just a copy that doesnt effect any outside data
javadoc - written with your code, effort to make documentation easier
assertion - run program with assertions enables to test program
debugger - lets you examine your code and execute 1 at a time
Unit test - test a method to see if the output is correct
Recursion - objects that contain objects of the same type or methods that call themselves
recursion pattern - have a base case then have a case that calls the method again until the base case is satisfied

static methods and variables - does not belong to any instance 
overloading - create methods with the same name and return type but have diff num of arguments
overriding - replaces a method from a parent class 
final variables - constant variables that cannot be changed once initialized
casting - change the variables type or reference type for objects
abstract class - cannot be instantiated, contains abstract methods. methods that arent defined meant for subclasses to defined
Interface - like an abstract class but all methods are abstract, classes must implement all methods, used mostly for polymorphism
Timer - used to call an actionEvent every given amount of ms
layout - organizes your panel or jcomponent
event - something that happens that event loop catches 
listeners - mouse listener, action listeners etc.
inner class - listeners are often inner classes, have access to the data of the class its in
exception - for handling errors that are caused by the outside world, not neccessarily the programmers errors
Stream - communicating between two entities, ordered sequence of bytes,
Readers & Writers - implement text processing, read bytes convert to chars, write to files, etc
File object - an object that can represent a file in the pc
Garbage collector - scans and finds useless memory then deletes it 

encapsulation - protecting data in classes from outside use so others don't have to think about how it works

inheritance - OOP allows classes to inherit from other classes 
	used for code reusability
	subclasses have access to parent classes public/protected data and methods

event handling - eventloop runs over and over waiting for something to set it off like user input
	-
		
MVC - Model - Data and program logic
	- View 	- Widgets and Panels (Components and Panels)
	- Controller - contains handlers. To tell the view and model how to behave
	
-------------------------How the Internet Works---------------------------

transport protocol: In charge of transporting bytes in proper order
	TCP: reliable, not as fast, makes sure to recieve all data, has error correction if bytes are missing it asks for them again
	UDP:	recieves packets of data, if some are missing it just drops it and continues, good for video streaming
application protocol: structure of the data
	HTTP: For webservers


socket:	
	setSoTimeout(int timeout); 	//set how long to wait on response before giving up

InetAddress:
	getLocalHost();
	getByName();				//InetAddress.getByName("cs.okstate.edu");
	getByAddress();
	isReachable(int timeout);

ServerSockets:
	accept();			//waits for a connection to be made, code stops at this until someone connects
	
Thread--------------------------------------------------------------------
Thread.setPriority(int newPriority);	//number from 1 to 10, higher numbers run more often
Thread.yield();		//tells java that this Thread can wait for others now

--------------------------------------Generics--------------------------------------------------------------
Integer a = 3000;
Integer b = 3000;
if(a == b){				//returns false because you are comparing two objects, which compares memory addresses

}

ArrayList list = new ArrayList();
list.add(5);									//automatically converts to an Integer object and adds it to the list
list.get(0);									//this returns an Object object does NOT automatically convert to an Integer object
note: you could do ((Integer)list.get(0)) but no thanks

ArrayList<Integer> list = new ArrayList<Integer>();
list.add(5);
list.get(0);			//now it knows that its returning an Integer object 


order of growth-----------------
O(1)		constant
O(log n)		sublinear
O(n)			linear
O(n log n)	
O(n^2)		quadratic			//double input equals quadrupal amount of work
O(n^k)		polynomial
O(2^n)		Exponential
O(n!)			Factorial

O(1)		size of the input has no influence

O(log n)	Algorithm doesnt have to look at every data element
			Recursion makes problem smaller through division
			
			
-------------------------------------------------Sorting-----------------------------------------Sorting-----------------------------------------Socket














